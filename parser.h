// parser.h

#ifndef COMPILER_PARSER_H
#define COMPILER_PARSER_H

#include <unordered_set>
#include <stack>
#include <optional>
#include <vector>
#include <unordered_map>
#include "builtinFunctions.h"
#include "treeNodes.h"
#include "lexer.h"

/**
 * @brief The Parser class handles the parsing of source code tokens into a
 * semantically correct abstract syntax tree (AST).
 */
class Parser {
public:
    /**
     * @brief Constructor for the Parser class.
     *
     * @param lexer A pointer to the Lexer object responsible for tokenizing the source code.
     */
    explicit Parser(Lexer *lexer) {
        this->lexer = lexer;
    }

    ~Parser() = default;

    /**
     * @brief Parses the entire program, generating an AST representing the program structure.
     *
     * @return A pointer to the root node of the AST.
     */
    ProgramTree *parseProgram();

    /**
     * @brief Attempts to parse a function definition.
     *
     * @return A pointer to the NodeFunction representing the parsed function, or nullptr if parsing fails.
     */
    NodeFunction *tryParseFunction();

    /**
     * @brief Parses a scope, which is a block of statements enclosed within curly braces.
     *
     * @return A pointer to the NodeScope representing the parsed scope.
     */
    NodeScope *parseScope();

    /**
     * @brief Attempts to parse a statement.
     *
     * @return A tuple containing a pointer to the parsed statement or nullptr and a
     * boolean indicating if need to continue to try and parse more statements.
     */
    std::tuple<NodeStmt *, bool> tryParseStmt();

    /**
     * @brief Parses an expression recursively.
     *
     * @return A pointer to the NodeExpr representing the root of parsed expression tree.
     */
    NodeExpr *parseExpr();

private:
    // An unordered map mapping token types to variable types.
    static std::unordered_map<TokenType, VariableType> typeMap;

    // A pointer to the Lexer object responsible for giving tokens of the source code
    Lexer *lexer;
    // A stack to keep track of nested scopes during parsing
    std::stack<NodeScopeP> scopes;
    // A pointer to the root of the tree generated by the parser
    ProgramTreeP programTree = nullptr;

    // Indicates whether a pointer is used in the current expression being parsed
    bool ptrUsedInExpr = false;
    // Indicates whether the main function has been encountered during parsing
    bool mainFunctionExists = false;

    /**
     * @brief Parses an address expression (unary '&').
     *
     * @return A pointer to the NodeExpr representing the parsed address expression.
     * @throws SemanticAnalysisException if a non-addressable factor was parsed
     */
    NodeExpr *parseAddrExpr();

    /**
     * @brief Parses a logical OR expression from the input token stream.
     *
     * @param leftSibling Pointer to the left sibling expression node.
     * @return Pointer to the parsed expression node representing the logical OR expression.
     * @throws SyntaxAnalysisException if an expression is expected but not found.
     */
    NodeExpr *parseLogicalOrExpr(NodeExprP leftSibling = nullptr);

    /**
    * @brief Parses a logical AND expression from the input token stream.
    *
    * @param leftSibling Pointer to the left sibling expression node.
    * @return Pointer to the parsed expression node representing the logical AND expression.
    * @throws SyntaxAnalysisException if an expression is expected but not found.
    */
    NodeExpr *parseLogicalAndExpr(NodeExprP leftSibling = nullptr);

    /**
     * @brief Parses an equality expression from the input token stream.
     *
     * - Equality expressions include equality and inequality operations.
     *
     * @param leftSibling Pointer to the left sibling expression node.
     * @param siblingOpType Type of the operator of the left sibling expression node.
     * @return Pointer to the parsed expression node representing the equality expression.
     * @throws SyntaxAnalysisException if an expression is expected but not found.
     */
    NodeExpr *parseEqualityExpr(NodeExprP leftSibling = nullptr,
                                TokenType siblingOpType = TokenType::NO_TOKEN);

    /**
     * @brief Parses a relational expression from the input token stream.
     *
     * - Relational expressions include greater than, greater than or equal to,
     * less than and less than or equal to operations.
     *
     * @param leftSibling Pointer to the left sibling expression node.
     * @param siblingOpType Type of the operator of the left sibling expression node.
     * @return Pointer to the parsed expression node representing the relational expression.
     * @throws SyntaxAnalysisException if an expression is expected but not found.
     */
    NodeExpr *parseRelationalExpr(NodeExprP leftSibling = nullptr,
                                  TokenType siblingOpType = TokenType::NO_TOKEN);

    /**
     * @brief Parses a numeric expression from the input token stream.
     *
     * - Numeric expressions include addition and subtraction operations.
     *
     * @param leftSibling Pointer to the left sibling expression node.
     * @param siblingOpType Type of the operator of the left sibling expression node.
     * @return Pointer to the parsed expression node representing the numeric expression.
     * @throws SyntaxAnalysisException if an expression is expected but not found.
     */
    NodeExpr *parseNumericExpr(NodeExprP leftSibling = nullptr,
                               TokenType siblingOpType = TokenType::NO_TOKEN);

    /**
     * @brief Parses a term from the input token stream.
     *
     * - Terms include multiplication, division, and modulo operations.
     *
     * @param leftSibling Pointer to the left sibling expression node.
     * @param siblingOpType Type of the operator of the left sibling expression node.
     * @return Pointer to the parsed expression node representing the term.
     * @throws SyntaxAnalysisException if an expression is expected but not found.
     */
    NodeExpr *parseTerm(NodeExprP leftSibling = nullptr,
                        TokenType siblingOpType = TokenType::NO_TOKEN);

    /**
     * @brief Parses a factor from the input token stream.
     *
     * - Factors include immediate integers, identifiers, unary operations, and parenthesized expressions.
     *
     * @param ptrNotAllowed Flag indicating whether pointer operations are not allowed for this factor.
     * @return Pointer to the parsed expression node representing the factor.
     * @throws SyntaxAnalysisException if an expression is expected but not found.
     * @throws SemanticAnalysisException if there's an illegal use of pointers or subscripting.
     */
    NodeExpr *parseFactor(bool ptrNotAllowed = false);

    /**
     * @brief Parses a factor expression based on an identifier token.
     *
     * If the identifier is followed by an open parenthesis, it is considered a function call.
     * If the identifier is a variable, it may be subscripted or dereferenced depending on its type.
     *
     * @param ident The identifier token.
     * @param ptrNotAllowed Flag indicating whether pointers are allowed for this factor.
     * @return Pointer to the parsed expression node representing the factor.
     * @throws SemanticAnalysisException if there's an illegal use of pointers or subscripting.
     */
    NodeExpr *FactorByIdentifier(const Token &ident, bool ptrNotAllowed);

    /**
     * @brief Parses a factor expression based on a multiplication token.
     *
     * This function is used when encountering a multiplication token, which is used for pointer dereferencing.
     *
     * @return Pointer to the parsed expression node representing the factor.
     * @throws SemanticAnalysisException if a variable cannot be dereferenced.
     */
    NodeExpr *FactorByMultToken();

    /**
     * @brief Parses a factor expression based on an open parenthesis token.
     *
     * This function is used to parse an expression enclosed within parentheses.
     *
     * @return Pointer to the parsed expression node representing the factor.
     * @throws SyntaxAnalysisException if a closing parenthesis is expected but not found.
     * @throws SemanticAnalysisException if there's an invalid use of pointers within the expression.
     */
    NodeExpr *FactorByOpenParenthesis();

    /**
     * @brief Parses the expression inside array brackets.
     *
     * @return Pointer to the parsed expression node representing the array index.
     * @throws SyntaxAnalysisException if a closing square bracket is expected but not found.
     * @throws SemanticAnalysisException if there's an invalid use of pointers within the expression.
     */
    NodeExpr *parseArrayBrackets();

    /**
     * @brief Parses an expression enclosed within parentheses.
     *
     * @return Pointer to the parsed expression node representing the expression inside parentheses.
     * @throws SyntaxAnalysisException if an opening or closing parenthesis is expected but not found.
     * @throws SemanticAnalysisException if there's an invalid use of pointers within the expression.
     */
    NodeExpr *parseParenthesisExpr();

    /**
     * @brief Parses a list of variable declarations enclosed within parentheses.
     *
     * This function parses a list of variable declarations enclosed within
     * parentheses, used for function parameter declarations.
     *
     * @return Vector of parsed variables representing the function parameters.
     * @throws SyntaxAnalysisException if an opening or closing parenthesis is expected but not found,
     *         or if there's a syntax error in the parameter declaration.
     */
    std::vector<Variable> parseParenthesisVariableList();

    /**
     * @brief Parses a list of expressions enclosed within parentheses.
     *
     * This function parses a list of expressions enclosed
     * within parentheses, used for function call arguments.
     *
     * @return Vector of parsed expression nodes.
     * @throws SyntaxAnalysisException if an opening or closing parenthesis is expected but not found,
     *         or if there's a syntax error in the expression list.
     * @throws SemanticAnalysisException if there's an invalid use of pointers within the expressions.
     */
    std::vector<NodeExpr *> parseParenthesisExprList();

    /**
     * @brief Parses a function call expression.
     *
     * This function parses a function call expression based on the provided identifier token,
     * and optionally checks the validity of the return value and pointer usage.
     *
     * @param ident The identifier token representing the function name.
     * @param ignoreReturnValue Flag indicating whether to ignore the return value validation.
     * @param ptrNotAllowed Flag indicating whether pointer usage is not allowed in the context.
     * @return Pointer to the parsed function call node.
     * @throws SemanticAnalysisException if the function being called is undeclared,
     *         if it's of type void and a return value is expected,
     *         or if there's an invalid use of pointers.
     */
    NodeFunctionCall *parseFunctionCall(const Token &ident, bool ignoreReturnValue, bool ptrNotAllowed = false);

    /**
     * @brief Checks if pointer operations are used within the expression.
     *
     * @param expr Pointer to the expression node to be deleted if invalid use detected.
     * @throws SemanticAnalysisException if an invalid use of pointers is detected.
     */
    void checkPointerUsage(NodeExprP expr);

    /**
     * @brief Checks if a variable exists in the current scope.
     *
     * @param varName The name of the variable to check.
     * @return An optional containing the variable if found; otherwise, an empty optional.
     */
    std::optional<Variable> varExistsCurrentScope(const std::string &);

    /**
     * @brief Checks if a variable exists in the scope stack.
     *
     * @param varName The name of the variable to check.
     * @return An optional containing the variable if found; otherwise an empty optional.
     */
    std::optional<Variable> varExistsScopeStack(const std::string &);

    /**
     * @brief Retrieves the variable from the scope stack or function parameters.
     *
     * @param varName The name of the variable to retrieve.
     * @return The Variable object representing the variable.
     * @throws SemanticAnalysisException if the variable is not found in the current scope stack or function parameters.
     */
    Variable getVarScopeStack(const std::string &);

    /**
     * @brief Adds a variable to the current scope.
     *
     * @param var The variable to add to the scope.
     */
    void addVarToCurrentScope(const Variable &);

    /**
     * @brief Retrieves a function by name from the program tree.
     *
     * @param funcName The name of the function to retrieve.
     * @return A pointer to the function if found, otherwise nullptr.
     */
    NodeFunction *getFunction(const std::string &);

    /**
     * @brief Checks if the current token's type matches the specified type.
     *
     * @param type The token type to check against.
     * @return True if the current token's type matches the specified type; false otherwise.
     */
    bool checkForTokenType(TokenType type);

    /**
     * @brief Checks if the current token type matches the specified type and consumes the token.
     *
     * @param type The token type to check against.
     * @return True if the current token's type matches the specified type; false otherwise.
     */
    bool checkForTokenTypeAndConsume(TokenType type);

    /**
     * @brief Checks if the current token type matches the specified type and consumes the token if it does.
     *
     * @param type The token type to check against.
     * @return True if the current token's type matches the specified type; false otherwise.
     */
    bool checkForTokenTypeAndConsumeIfYes(TokenType type);

    /**
     * @brief Checks if the current token is an identifier.
     *
     * @throws SyntaxAnalysisException If the current token is not an identifier.
     */
    void identifierTokenExists();

    /**
     * @brief Validates the parameters of a function call.
     *
     * @param params The parameters passed in the function call.
     * @param func Pointer to the function being called.
     *
     * @throws SemanticAnalysisException If the number or types of parameters are
     * incompatible with the function's signature.
     */
    static void validateFunctionCallParams(std::vector<NodeExprP> params, NodeFunctionP func);

    /**
     * @brief Parses a statement based on an identifier token.
     *
     * This function analyzes the token following the identifier to determine the type of statement
     * to parse. If an open parenthesis token is encountered, indicating a function call, it parses
     * the function call statement. If an equal sign is encountered, it parses a primitive assignment
     * statement. If an open square bracket is encountered, it parses an array assignment statement.
     *
     * @param ident The token representing the identifier.
     * @return A pointer to the parsed statement node, or nullptr if the token does not lead
     * to a recognizable statement type.
     */
    NodeStmt *stmtByIdentifier(const Token &ident);

    /**
     * @brief Parses an assignment statement for a primitive variable.
     *
     * @param var The variable to which the assignment is made.
     * @return Pointer to the parsed assignment statement node.
     * @throws SemanticAnalysisException If there are incompatible pointer types,
     * invalid assignment or if trying to assign to an array.
     */
    NodeStmt *stmtPrimitiveAssignment(const Variable &var);

    /**
    * @brief Parses an array assignment statement.
    *
    * This function parses an array assignment statement, ensuring that the array is subscriptable
    * and then parsing the index expression for the assignment. If an assignment operator is found,
    * it parses the expression and creates a new array assignment statement node.
    *
    * @param var The variable representing the array being assigned.
    * @return A pointer to the created array assignment statement node, or nullptr if no
    * assignment operator is found.
    * @throws SemanticAnalysisException If the variable is not subscriptable, or if there is an
    * invalid use of pointers in the assignment.
    */
    NodeStmt *stmtArrayAssignment(const Variable &var);

    /**
     * @brief Parses a statement for pointer value assignment by dereferencing.
     *
     * @param ident The token representing the identifier of the subscriptable variable.
     * @return A pointer to the parsed statement node, or nullptr if no assignment is found.
     * @throws SemanticAnalysisException If the variable cannot be dereferenced.
     */
    NodeStmt *stmtPtrValueAssignment(const Token &ident);

    /**
     * @brief Parses a statement for variable declaration.
     *
     * This function parses a statement where a variable is declared. If all conditions are met, the
     * variable is added to the current scope. If the variable is assigned a value during declaration,
     * a statement node representing the assignment is returned. Otherwise, nullptr is returned.
     *
     * @param type The type of the variable being declared.
     * @return A pointer to the parsed statement node, or nullptr if no assignment is found.
     * @throws SemanticAnalysisException If the variable is redeclared in the current scope,
     * if arrays are of pointer type, or if the array size is not known at compile time.
 */
    NodeStmt *stmtVariableDeclaration(VariableType type);

    /**
     * @brief Parses an 'if' statement.
     *
     * Parses the 'if' statement, including condition expression and code blocks for both if and else branches.
     *
     * @return A pointer to the parsed 'if' statement node.
     * @throws SyntaxAnalysisException If there is a syntax error in the expression or either of the scopes.
     * @throws SemanticAnalysisException If there is a use of pointers in the expression or a
     * semantic error is met in either of the scopes.
     */
    NodeStmt *stmtIf();

    /**
     * @brief Parses a 'while' or 'do-while' loop statement.
     *
     * Parses either a 'while' loop or a 'do-while' loop statement, including condition expression and code block.
     *
     * @param isDo Boolean indicating if it's a 'do-while' loop (true) or a 'while' loop (false).
     * @return A Pointer to the parsed loop statement node.
     * @throws SyntaxAnalysisException If there is a syntax error in the expression, in the scope
     * or a while keyword is absent in a 'do-while' loop.
     * @throws SemanticAnalysisException If there is a use of pointers in the expression or a
     * semantic error is met in code scope.
     */
    NodeStmt *stmtWhile(bool isDo = false);
};

inline std::unordered_map<TokenType, VariableType> Parser::typeMap = {
        {TokenType::intKeyword,  VariableType::intType},
        {TokenType::charKeyword, VariableType::charType},
        {TokenType::voidKeyword, VariableType::voidType},
};

#endif //COMPILER_PARSER_H
